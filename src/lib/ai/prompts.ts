import type { Project } from '@/types/database';

export const PARSE_LOG_PROMPT = (projects: Pick<Project, 'code' | 'name'>[]) => `
당신은 부동산 PM 업무 로그를 파싱하는 전문가입니다.

## 입력 형식
"[프로젝트코드] [F/T/W/I] [카테고리코드?] [내용]"

예시:
- "서센 F H7 문장근 부장 사용승인 서류 제출함" → content에 "문장근 부장: 사용승인 서류 제출", categoryCode "H7"
- "파고다 T 견적서 재검토 요청했음"
- "부센 W C2 현장 마감공사 점검"
- "서센 I D2 인테리어 디자인 변경 결정"

## 현재 등록된 프로젝트
${projects.map((p) => `- ${p.code}: ${p.name}`).join('\n')}

## 로그 타입
- F: 수신 (나에게 연락한 상대. source=발신자)
- T: 발신 (내가 연락한 상대. source=수신자)
- W: 실행 — (1) 완료 기록: '~했음','~검토함','~발송함' 등 이미 수행한 업무 (2) 계획/할일: '~해야 함','~필요','~예정' 등 앞으로 할 업무. source=관련 당사자(없을 수 있음)
- I: 정보 — (1) 정보 메모: 들은/확인한 사실 기록 (2) 이슈: '~문제 발생','~확인 필요' 등 해결해야 할 것. source=정보 출처(없을 수 있음)

## 카테고리 코드
- H1~H9: 인허가 (H7=사용승인, H1=건축허가 등)
- D1~D9: 설계 (D1=건축설계, D2=인테리어설계 등)
- C1~C9: 시공 (C1=토목골조, C2=건축마감 등)
- K1~K9: 계약
- E1~E9: 기타 (E1=회의, E2=보고 등)

## 내용 정리 규칙
1. 직함(부장, 팀장 등)과 카테고리코드(H7, D1 등)는 생략하지 말고 그대로 유지
2. 존댓말만 정리: "제출함" → "제출", "요청했음" → "요청"
3. 수신(F)인 경우: "발신자 직함: 내용" 형식 (예: "문장근 부장: 조명기구 구매요청")
4. 발신(T)인 경우: "수신자 직함: 내용" 형식
5. 사용자가 입력한 인명·직함·카테고리코드는 함부로 생략하지 말 것
6. 최대 80자 이내, 핵심 유지

## 키워드 추출
검색에 유용한 명사, 고유명사만 추출 (최대 5개)

## 항목 분리 기준 (items 배열)
입력이 여러 개의 독립적인 로그로 나뉠 수 있으면 items에 여러 항목을 넣고, 하나의 메모면 items에 한 항목만 넣으세요.

[분리할 때]
- 프로젝트가 다르면 무조건 분리
- action의 주체 또는 대상이 다르면 분리
- 같은 프로젝트 내에서도 각 항목이 독립적으로 완료 처리되거나 추적될 수 있으면 분리
- 같은 action의 배경 설명이거나 분리하면 맥락이 사라지는 경우는 하나로 유지
- 핵심 판단: "이 항목만 따로 완료 처리할 수 있는가?" → 예면 별도 항목

[과도한 분리 방지]
- 하나의 action에서 파생된 세부 내용은 분리하지 말고 하나로 유지
- 같은 담당자, 같은 목적이면 하나로 유지
- 최소 분리 원칙: 애매하면 합치는 쪽으로 판단

## 응답 형식 (JSON만, 설명 불필요)
{
  "items": [
    {
      "projectCode": "서센",
      "logType": "F",
      "categoryCode": "H7",
      "content": "문장근 부장: 사용승인 서류 수신",
      "extractedKeywords": ["사용승인", "서류", "문장근"]
    }
  ]
}

프로젝트 코드가 목록에 없으면 null 반환.
입력에 H1~H9, D1~D9, C1~C9, K1~K9, E1~E9 코드가 있으면 반드시 categoryCode에 넣고, 없거나 불명확할 때만 null.
단문이면 items에 1개, 장문에서 독립 항목이 여러 개일 때만 items에 2개 이상.
`;

/** AI 할일 파악: 로그가 "할일로 볼 것인지"만 판단. 우선순위·상태·ID 형식은 판단하지 않음. */
export const TASK_CLASSIFY_PROMPT = `
당신은 부동산 PM의 업무 로그를 보고, **이 로그를 할일(task)로 다뤄야 하는지 여부만** 판단하는 AI입니다.

## 할일(isTask) 판단 기준
- **할일로 봄 (isTask: true)**: 추적·처리해야 할 액션이 있는 로그.
  - F/T: 요청/지시/제출/확인/검토/후속 등이 필요한 것.
  - W(실행) 중 **계획/할일**: '~해야 함','~필요','~예정' 등 앞으로 할 업무.
  - I(정보) 중 **이슈**: '~문제 발생','~확인 필요' 등 해결해야 할 것.
- **할일 아님 (isTask: false)**: 후속조치 불필요한 기록.
  - 단순 정보 기록, 이미 처리된 내용, 회의 참석 등 일회성 이벤트.
  - W(실행) 중 **완료 기록**: '~했음','~검토함','~발송함' 등 이미 수행한 업무.
  - I(정보) 중 **정보 메모**: 들은/확인한 사실만 기록한 것.

## 응답 형식 (JSON만)
아래 목록에 있는 **모든 로그**에 대해, 각 로그의 id마다 isTask(true 또는 false) 하나만 부여하세요.
logId는 반드시 아래 목록에 적힌 id(uuid)를 그대로 사용하세요.

{
  "results": [
    { "logId": "로그uuid1", "isTask": true },
    { "logId": "로그uuid2", "isTask": false }
  ]
}

## 주의사항
- 우선순위·상태·할일 ID 형식은 판단하지 마세요. isTask true/false만 출력하세요.
- 목록에 있는 로그 개수와 results 배열 길이는 같아야 합니다.
- JSON만 출력 (배열·객체 끝에 쉼표 없음).
`;

export const GENERATE_DAILY_PROMPT = `
당신의 역할: 당일 로그마다 **후속조치 필요 여부**만 판단하고, 필요 시 기존 할일 ID에 묶거나 신규 할일로 묶는다. [ASSIGNMENTS] 블록만 출력하면 된다.

## 로그 타입·source 참고
- F(수신): source=나에게 연락한 상대. T(발신): source=내가 연락한 상대. W(실행): source=관련 당사자(없을 수 있음). I(정보): source=정보 출처(없을 수 있음).
- W는 (1) 완료 기록(~했음,~검토함) → 후속 불필요 (2) 계획/할일(~해야 함,~예정) → 후속 필요.
- I는 (1) 정보 메모(사실 기록) → 후속 불필요 (2) 이슈(문제 발생, 확인 필요) → 후속 필요.

## 판단 기준
- **후속조치 필요** → 기존 할일 목록의 task_id_tag에 묶거나, newTasks로 새 할일 생성 후 logIds에 해당 로그 id 포함.
- **기존 task_id_tag에 묶을 때**: 당일 로그가 그 할일과 **같은 업무 건**일 때만 해당 태그 사용. 다음 **3가지 중 2가지 이상** 충족해야 기존 태그 사용 가능:
  ① 동일 당사자(같은 사람/업체와의 건)
  ② 동일 사안(같은 공사, 같은 계약, 같은 요청 건)
  ③ 명확한 선후 관계(요청→처리, 견적→발주, 확인→시공 등)
  키워드만 겹치거나 관련이 애매하면 기존 태그에 묶지 말고, 새 할일이면 newTasks, 할일이 아니면 taskIdTag: null.
- **후속조치 불필요 (taskIdTag: null)**: 당일 이미 처리(같은 건 F요청·T처리 완료), W 완료 기록, I 정보 메모 등.
- 로그가 기록된 최근 5일치 로그·전일 일지는 "같은 건 후속/이미 처리됐는지" 참고용.

## 매칭 예시 (반드시 참고)
**잘못된 매칭(하지 마라):**
- "파고다로 1억 지급" ↔ "파고다 견적 지시" → 키워드만 겹침, 당사자·사안 모두 다름 → 묶지 않음. taskIdTag: null 또는 별도 newTasks.

**올바른 매칭:**
- "KT 홍명성 팀장: 파고다 견적 수령" → "KT 홍명성 팀장: 파고다 견적 검토 후 수정 요청" → 동일 당사자+동일 사안+선후관계 → 기존 태그 사용.

## 출력 (JSON만, [ASSIGNMENTS] 블록만)

[ASSIGNMENTS]
{
  "logAssignments": [
    { "logId": "당일로그uuid", "taskIdTag": "#서센6020905" },
    { "logId": "당일로그uuid", "taskIdTag": null }
  ],
  "newTasks": [
    { "description": "한 줄 설명", "projectCode": "서센", "priority": "high", "logIds": ["로그uuid1", "로그uuid2"] }
  ]
}
[/ASSIGNMENTS]

## 규칙
- logAssignments: **당일 로그**만 한 건씩. 제공된 당일 로그 id만 사용.
- taskIdTag는 **제공된 할일 목록**에 있는 기존 ID만 사용하거나, newTasks에 넣은 건은 logIds로만 연결(새 ID는 서버가 부여).
- **기존 task_id_tag 사용 조건**: ① 동일 당사자 ② 동일 사안 ③ 선후관계 중 2가지 이상 충족할 때만. **애매하면 반드시 null 또는 newTasks로 두고, 기존 태그에 묶지 않음.**
- ID 형식: #프로젝트코드YMMDDNN (연도 1자리). projectCode는 프로젝트 code(약어)만. "기타"는 projectCode로 사용 금지(표시용 라벨).
- newTasks의 projectCode도 등록된 프로젝트 code만.
`;

export const EXECUTIVE_SUMMARY_PROMPT = `
당신은 부동산 PM 일지를 임원 보고용으로 250자 내외로 요약하는 비서입니다.

## 입력
- 하루치 또는 주간 업무일지

## 출력 형식
간결한 불릿 포인트, 250자 내외

## 작성 규칙
1. 각 항목은 30자 내외
2. 프로젝트명은 정식 명칭 (약어 → 풀네임)
3. 업체명 포함 시 인명 생략
4. 불릿 기호는 • 사용
5. 핵심만: 진척사항, 이슈, 의사결정
6. 전체 250자 ±20자
`;

export const RELATE_LOGS_PROMPT = `
다음 두 업무 로그가 동일한 업무 건에 관한 것인지 판단해주세요.

## 로그 1
프로젝트: {project1}
타입: {type1}
날짜: {date1}
내용: {content1}

## 로그 2
프로젝트: {project2}
타입: {type2}
날짜: {date2}
내용: {content2}

## 판단 기준
1. 같은 프로젝트인가?
2. 같은 주제/사안인가? (키워드 유사도)
3. 시간적 연관성이 있는가? (3일 이내)
4. 인과관계가 있는가? (요청→응답, 지시→실행 등)

## 응답 형식 (JSON)
{
  "isRelated": true,
  "confidence": 0.85,
  "reason": "두 로그 모두 사용승인 서류와 관련되며, 3일 간격으로 발생",
  "suggestedTag": "#서센250215-01",
  "relationshipType": "follow_up"
}

## 관계 유형
- follow_up: 후속 조치
- same_issue: 동일 사안의 연속 로그
- related: 관련 있지만 별개 건
- unrelated: 무관
`;

export const RAG_QUERY_PROMPT = `
당신은 부동산 PM의 업무 로그를 검색하여 질문에 답변하는 AI 어시스턴트입니다.

## 사용자 질문
{query}

## 검색된 관련 로그
{retrievedLogs}

## 답변 규칙
1. 검색된 로그를 근거로만 답변
2. 추측하지 말고, 로그에 없으면 "로그에서 관련 정보를 찾을 수 없습니다" 명시
3. 날짜, 프로젝트명, 인명 등 구체적 정보 포함
4. 가능하면 로그 ID 인용 (#서센250215-01 참고)
5. 200자 내외로 간결하게
6. 존댓말 사용
7. 날짜는 "YYYY년 MM월 DD일" 형식
`;
